<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Understanding Modulo Bias | Julian through the Lens</title>
<meta property='og:title' content='Understanding Modulo Bias - Julian through the Lens'><meta property='og:description' content='Introduction It is often said that this code:
unsigned int randomNumber = rand() % k; is a bad idea, at least if you are expecting a uniform distribution. I&rsquo;m going to try and explore this topic in a more formal fashion than I have seen so far.
The reason why it is bad is pretty elementary and easy to understand: imagine you have a random generator that outputs values between \(0\) and \(9\) (i.'><meta property='og:url' content='https://julian.bayardo.info/post/understanding-modulo-bias/'><meta property='og:site_name' content='Julian through the Lens'><meta property='og:type' content='article'><meta property='og:image' content='https://www.gravatar.com/avatar/fdbc036a46f3c0903c7e39459db599c0?s=256'><meta property='article:section' content='Post'><meta property='article:tag' content='math'><meta property='article:tag' content='probability'><meta property='article:published_time' content='2018-05-02T20:26:06-03:00'><meta property='article:modified_time' content='2018-05-02T20:26:06-03:00'><meta name=twitter:card content='summary'><meta name=twitter:site content='@BayardoJulian'><meta name=twitter:creator content='@BayardoJulian'><link rel=alternate type=application/rss+xml title="Julian through the Lens" href=/post/index.xml><link rel=stylesheet href=/css/style.min.572ee845ad8da3c5d2a0a9e157da4b896325fafa6ff5b9b18ae122044000e00e.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://julian.bayardo.info/post/understanding-modulo-bias/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><script type=text/javascript src=https://julian.bayardo.info/js/vendor/plotly/plotly.min.js></script><script type=text/javascript src=https://julian.bayardo.info/js/vendor/mathjs/math.js></script></head><body><header class=section><div class=container><nav id=nav-main class=nav><div id=nav-name class=nav-left><a id=nav-anchor class=nav-item href=https://julian.bayardo.info/><h1 id=nav-heading class="title is-4">Julian through the Lens</h1></a></div><div class=nav-right><nav id=nav-items class="nav-item level is-mobile"><a class=level-item aria-label=github href=https://github.com/jbayardo target=_blank rel=noopener><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</i></span></a><a class=level-item aria-label=email href=mailto:julian@bayardo.info target=_blank rel=noopener><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
</i></span></a><a class=level-item aria-label=linkedin href=https://linkedin.com/in/jbayardo target=_blank rel=noopener><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path stroke-width="1.8" d="m5.839218 4.101561c0 1.211972-.974141 2.194011-2.176459 2.194011S1.4863 5.313533 1.4863 4.101561c0-1.211094.974141-2.194011 2.176459-2.194011s2.176459.982917 2.176459 2.194011zm.017552 3.94922H1.468748v14.04167H5.85677V8.050781zm7.005038.0H8.501869v14.04167h4.360816v-7.370999c0-4.098413 5.291077-4.433657 5.291077.0v7.370999h4.377491v-8.89101c0-6.915523-7.829986-6.66365-9.669445-3.259423V8.050781z"/></svg></i></span></a></nav></div></nav><nav class=nav><div class=nav-left><a class=nav-item href=/search><h2 class="title is-5">Search</h2></a><a class=nav-item href=/series><h2 class="title is-5">Series</h2></a><a class=nav-item href=/tags><h2 class="title is-5">Tags</h2></a></div><div class=nav-right><a class=nav-item href=/about><h2 class="title is-5">About me</h2></a><a class=nav-item href=/disclaimer><h2 class="title is-5">Disclaimer</h2></a></div></nav></div><script src=/js/navicon-shift.min.c7620c1a856fc9aead68a6e5fa7d6a739ac88b0ef5eb6834fb6dacf7dc82adc3.js integrity="sha256-x2IMGoVvya6taKbl+n1qc5rIiw7162g0+22s99yCrcM=" crossorigin=anonymous async defer></script></header><section class="section article-section"><article class=article data-pagefind-body><div class=article-container><div class=container><div class="subtitle tags is-6 is-pulled-right"><a class="tag is-6 is-link" href=/tags/math data-pagefind-filter=tag><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
math</a>
<a class="tag is-6 is-link" href=/tags/probability data-pagefind-filter=tag><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
probability</a></div><h2 class="subtitle is-6" data-pagefind-meta=date>May 2, 2018</h2><h1 class=title data-pagefind-meta=title>Understanding Modulo Bias</h1><div class="content article"><nav class="table-of-contents boxed"><h2 class=title>Table of Contents</h2><nav id=TableOfContents><ol><li><a href=#introduction>Introduction</a></li><li><a href=#how-bad-is-it>How bad is it?</a></li><li><a href=#how-can-i-fix-this>How can I fix this?</a></li><li><a href=#what-now>What now?</a></li></ol></nav></nav><h1 id=introduction>Introduction
<a href=#introduction style=float:right;border-bottom:0><svg width="16" height="16" viewBox="0 0 8 8"><path d="M5.88.03c-.18.01-.36.03-.53.09-.27.1-.53.25-.75.47a.5.5.0 10.69.69c.11-.11.24-.17.38-.22.35-.12.78-.07 1.06.22.39.39.39 1.04.0 1.44l-1.5 1.5c-.44.44-.8.48-1.06.47-.26-.01-.41-.13-.41-.13a.5.5.0 10-.5.88s.34.22.84.25 1.2-.16 1.81-.78l1.5-1.5c.78-.78.78-2.04.0-2.81-.28-.28-.61-.45-.97-.53-.18-.04-.38-.04-.56-.03zm-2 2.31c-.5-.02-1.19.15-1.78.75L.6 4.59c-.78.78-.78 2.04.0 2.81.56.56 1.36.72 2.06.47.27-.1.53-.25.75-.47a.5.5.0 10-.69-.69c-.11.11-.24.17-.38.22-.35.12-.78.07-1.06-.22-.39-.39-.39-1.04.0-1.44l1.5-1.5c.4-.4.75-.45 1.03-.44.28.01.47.09.47.09a.5.5.0 10.44-.88s-.34-.2-.84-.22z"/></svg></a></h1><p>It is often said that this code:</p><pre><code>unsigned int randomNumber = rand() % k;
</code></pre><p>is a bad idea, at least if you are expecting a uniform distribution. I&rsquo;m going to try and explore this topic in a more formal fashion than I have seen so far.</p><p>The reason why it is bad is pretty elementary and easy to understand: imagine you have a random generator that outputs values between \(0\) and \(9\) (i.e. <code>RAND_MAX</code> is \(10\)), and you wanted values between \(0\) and \(2\) (so you would set \(k = 3\) ). Then, we have the following mapping:</p><table><tr><th>rand()</th><th>Random Number</th></tr><tr><td>0, 3, 6, 9</td><td>0</td></tr><tr><td>1, 4, 7</td><td>1</td></tr><tr><td>2, 5, 8</td><td>2</td></tr></table><p>So, effectively, the \(P(\text{randomNumber} = 2) = \frac{3}{10}\); in contrast, \(P(\text{randomNumber} = 0) = \frac{4}{10}\). Essentially, the problem lies in the fact that since \(k\) does not evenly divide <code>RAND_MAX</code>, this gets you up to \(1\) more value falling into the first few numbers in the range. To get a feeling for this, you can play around with the plot below, which shows the precise probabilities for different values of <code>RAND_MAX</code> and \(k\):</p><div style=display:flex;margin:auto><div style="flex:0 0 50%;margin-top:50pt"><form><fieldset><label for=modulo-bias-M><code>RAND_MAX</code></label>
<input id=modulo-bias-M type=number min=0 max=1000 value=11 step=1 placeholder=M></fieldset><fieldset><label for=modulo-bias-k>k</label>
<input id=modulo-bias-k type=number min=1 max=1000 value=10 step=1 placeholder=k></fieldset></form></div><div id=modulo-bias-plot style=flex:1></div></div><p>Effectively, the effect of the parameter \(k\) becomes more pronounced when the value of \(M \% k\) gets bigger; until it gets too big (i.e. \(k = M - 1\)), and then it is almost as if you didn&rsquo;t have the problem. More formally, we can analyze this by setting \(X\) to be a discrete random variable such that \(R_X = \{0, &mldr;, M-1\}\), with \(M-1 \in \mathbb{N}\) being the highest achievable number for the random generator and \(P(X = i) = \frac{1}{M}\).</p><p>Let \(Y = X \% k\). What we want is to find out what the probability distribution function of \(Y\) is, since that will give us a way to properly understand what is happening. First of all, notice that \(R_Y = \{0, &mldr;, k-1\}\). Hence, the probability:</p><script type="math/tex;mode=display">P(Y = i) = P(\cup_{j \in J_i} (X = j)) = \sum_{j \in J_i} P(X = j) = \frac{\#J_i}{M}
</script><p>Where \(J_i = \{x \in R_X : x \equiv i \text{(mod} k\text{)}\}\). Concretely, the probability that \(Y\) is in any particular equivalence class, is the number of elements in the class over the total number of elements we get to pick from. So the next thing to do is to calculate \(\#J_i\).</p><p>Elements belonging to \(J_i\) all have the same form: \(qk + i\), with \(q \in \mathbb{Z}\). However, they are bounded above by \(M-1\), and below by \(i\):</p><script type="math/tex;mode=display">i \leq qk + i \leq M-1 \implies 0 \leq q \leq \lfloor\frac{M - 1 - i}{k}\rfloor
</script><p>Thus, \(\#J_i = \lfloor\frac{M - 1 - i}{k}\rfloor + 1\). Meaning that our probability distribution function is</p><script type="math/tex;mode=display">P(Y = i) = \frac{\lfloor \frac{M - 1 - i}{k} \rfloor + 1}{M}
</script><p>We want to see that this sums to \(1\), since this would confirm that it is a probability distribution. I will use use the identities \(\lceil \frac{a}{b} \rceil = \lfloor \frac{a - 1}{b} \rfloor + 1\) and \(a = \sum_{i=0}^{b-1} \lceil \frac{a - i}{b} \rceil\), both proofs can be found in {1}:</p><script type="math/tex;mode=display">\begin{split}
\sum_{i \in R_Y} P(Y = i) &= \sum_{i=0}^{k-1} (\frac{\lfloor\frac{M - 1 - i}{k}\rfloor + 1}{M}) \\
&= \frac{1}{M} \sum_{i=0}^{k-1} (\lfloor\frac{M - 1 - i}{k}\rfloor + 1) \\
&= \frac{1}{M} \sum_{i=0}^{k-1} \lceil\frac{M - i}{k}\rceil \\
&= \frac{1}{M} M = 1
\end{split}
</script><p>The fact that the distribution depends on the value of \(i\) is already a problem: we were seeking a uniform distribution, and hence expecting that \(P(Y=i) = \frac{1}{k}\). If you plot the function, you will see exactly the same plot as you were playing with above.</p><h1 id=how-bad-is-it>How bad is it?
<a href=#how-bad-is-it style=float:right;border-bottom:0><svg width="16" height="16" viewBox="0 0 8 8"><path d="M5.88.03c-.18.01-.36.03-.53.09-.27.1-.53.25-.75.47a.5.5.0 10.69.69c.11-.11.24-.17.38-.22.35-.12.78-.07 1.06.22.39.39.39 1.04.0 1.44l-1.5 1.5c-.44.44-.8.48-1.06.47-.26-.01-.41-.13-.41-.13a.5.5.0 10-.5.88s.34.22.84.25 1.2-.16 1.81-.78l1.5-1.5c.78-.78.78-2.04.0-2.81-.28-.28-.61-.45-.97-.53-.18-.04-.38-.04-.56-.03zm-2 2.31c-.5-.02-1.19.15-1.78.75L.6 4.59c-.78.78-.78 2.04.0 2.81.56.56 1.36.72 2.06.47.27-.1.53-.25.75-.47a.5.5.0 10-.69-.69c-.11.11-.24.17-.38.22-.35.12-.78.07-1.06-.22-.39-.39-.39-1.04.0-1.44l1.5-1.5c.4-.4.75-.45 1.03-.44.28.01.47.09.47.09a.5.5.0 10.44-.88s-.34-.2-.84-.22z"/></svg></a></h1><p>How bad this is depends on what you are doing. A more interesting question is how to quantify how bad it can be. One way to go about quantifying is to measure how different the distribution of \(Y\) is with respect to the distribution of \(Z\); <a href=https://en.wikipedia.org/wiki/Divergence_(statistics)>there are a myriad of ways to do this</a>&nbsp;<img src=/img/logos/wikipedia.svg alt="Site Logo" style=height:1em;vertical-align:middle;margin-right:5px>, but I am going to use the <a href=https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence>Kullback-Leibler divergence</a>&nbsp;<img src=/img/logos/wikipedia.svg alt="Site Logo" style=height:1em;vertical-align:middle;margin-right:5px>.</p><p>Thus, suppose \(Z\) was a uniformly distributed random variable such that \(R_Z = \{0, .., k - 1\}\) (i.e. the actual distribution we wanted to achieve). Given some \(M\), we know that \(k\) can range between \(1 \leq k \leq M - 1\); for each of these values, we have one probability distribution, call it \(Y\), and we can compute \(\text{KL}(Z||Y)\):</p><div style=display:flex;margin:auto><div style="flex:0 0 50%;margin-top:50pt"><fieldset><label for=modulo-distribution-M>M</label>
<input id=modulo-distribution-M type=number min=0 value=2000 step=1 placeholder=M></fieldset></div><div id=modulo-distribution-plot style=flex:1></div></div><p>If you look at different values of \(M\), it will become clear that \(\text{KL}(Z||Y)\) only reaches 0 when \(k\) evenly divides \(M\); and thus some values of \(M\) don&rsquo;t ever get a point that reaches \(0\); specifically, these are the prime numbers.</p><p>Furthermore, the space between the zeros becomes bigger and bigger as \(M\) increases. This is basically because even divisors of \(M\) are more spaced out as they get larger; this is easy to see by looking at the prime decomposition of \(M = \prod_{i=1}^b p_i^{r_i} \): every even divisor can only look just like the decomposition, just with a lesser or equal value for each \(r_i\), which means that increases in value are multiplicative!.</p><p>The last key to understand this is the parabolas. Why do we have an inverted parabola between each even divisor?. That is simply because of how modulo works!:</p><ul><li>When increasing \(k\), one more value gets biased. This means that the generated distribution drifts away from the target distribution \(Z\).</li><li>When the number of biased values (\(M \% k\)) is roughly \(\frac{k}{2}\), we reach the highest point of the parabola.</li><li>After this we can only decrease: as more values become biased, the distribution becomes more and more like an uniform distribution again.</li></ul><h1 id=how-can-i-fix-this>How can I fix this?
<a href=#how-can-i-fix-this style=float:right;border-bottom:0><svg width="16" height="16" viewBox="0 0 8 8"><path d="M5.88.03c-.18.01-.36.03-.53.09-.27.1-.53.25-.75.47a.5.5.0 10.69.69c.11-.11.24-.17.38-.22.35-.12.78-.07 1.06.22.39.39.39 1.04.0 1.44l-1.5 1.5c-.44.44-.8.48-1.06.47-.26-.01-.41-.13-.41-.13a.5.5.0 10-.5.88s.34.22.84.25 1.2-.16 1.81-.78l1.5-1.5c.78-.78.78-2.04.0-2.81-.28-.28-.61-.45-.97-.53-.18-.04-.38-.04-.56-.03zm-2 2.31c-.5-.02-1.19.15-1.78.75L.6 4.59c-.78.78-.78 2.04.0 2.81.56.56 1.36.72 2.06.47.27-.1.53-.25.75-.47a.5.5.0 10-.69-.69c-.11.11-.24.17-.38.22-.35.12-.78.07-1.06-.22-.39-.39-.39-1.04.0-1.44l1.5-1.5c.4-.4.75-.45 1.03-.44.28.01.47.09.47.09a.5.5.0 10.44-.88s-.34-.2-.84-.22z"/></svg></a></h1><p>Perhaps the easiest fix is to do:</p><pre><code>unsigned int randomNumber = k;
while (randomNumber &gt;= k) randomNumber = rand(); 
</code></pre><p>This works just as intended: the produced number is always between \(0\) and \(k-1\), and it is distributed uniformly in the range. To see this, imagine we set \(T_i\) to be independent, identically distributed with a uniform distribution between \(0\) and \(M-1\); then we can compute the PDF of \(T\):</p><script type="math/tex;mode=display">\begin{split}
P(T = i) &= \sum_{r=1}^{\infty} P(\wedge_{j=1}^{r - 1} T_j \geq k \wedge T_r = i) \\
    &= \sum_{r=1}^{\infty} P(T_r = i) \prod_{j=1}^{r-1} P(T_j \geq k) \\
    &= \sum_{r=1}^{\infty} \frac{1}{M} (1 - \frac{k}{M})^{r-1} \\
    &= \frac{1}{M} \sum_{r=0}^{\infty} (1 - \frac{k}{M})^{r} \\
    &= \frac{1}{M} \frac{1}{1 - (1 - \frac{k}{M})} \\
    &= \frac{1}{k}
\end{split}
</script><p>Which now looks exactly as we wanted it to!. Perhaps the next interesting question is how many times will we call <code>rand()</code> until we find a number that satisfies the constraint.</p><p>This can be easily answered: the probability that we receive a random number in the range is \(\frac{k}{M}\), and the random numbers generated are independent of each other; which means that the number of iterations \(N\) is a <a href=https://en.wikipedia.org/wiki/Geometric_distribution>geometric random variable</a>&nbsp;<img src=/img/logos/wikipedia.svg alt="Site Logo" style=height:1em;vertical-align:middle;margin-right:5px>. Hence, we have that \(N \sim \text{Geometric}(\frac{k}{M})\), and thus we can expect to take \(\mathbb{E}[N] = \frac{M}{k}\) iterations until we generate a random number.</p><p>The expectation points out a problem in our code: if \(M \gg k\), which often happens in practical implementations where \(M\) is the maximum representable number, then the number of iterations is going to be high.</p><h1 id=what-now>What now?
<a href=#what-now style=float:right;border-bottom:0><svg width="16" height="16" viewBox="0 0 8 8"><path d="M5.88.03c-.18.01-.36.03-.53.09-.27.1-.53.25-.75.47a.5.5.0 10.69.69c.11-.11.24-.17.38-.22.35-.12.78-.07 1.06.22.39.39.39 1.04.0 1.44l-1.5 1.5c-.44.44-.8.48-1.06.47-.26-.01-.41-.13-.41-.13a.5.5.0 10-.5.88s.34.22.84.25 1.2-.16 1.81-.78l1.5-1.5c.78-.78.78-2.04.0-2.81-.28-.28-.61-.45-.97-.53-.18-.04-.38-.04-.56-.03zm-2 2.31c-.5-.02-1.19.15-1.78.75L.6 4.59c-.78.78-.78 2.04.0 2.81.56.56 1.36.72 2.06.47.27-.1.53-.25.75-.47a.5.5.0 10-.69-.69c-.11.11-.24.17-.38.22-.35.12-.78.07-1.06-.22-.39-.39-.39-1.04.0-1.44l1.5-1.5c.4-.4.75-.45 1.03-.44.28.01.47.09.47.09a.5.5.0 10.44-.88s-.34-.2-.84-.22z"/></svg></a></h1><p>Well, the problem with the last idea is that we discard most of the numbers that we generate, while the problem with the former idea is that there are a set of numbers that bias our generator. The next idea is to try to discard just the numbers that bias the generator.</p><p>We can write \(M\) as \(\lfloor \frac{M}{k} \rfloor k + (M \% k)\); if we did the modulo technique on a generator with output between \(0\) and \(\lfloor \frac{M}{k} \rfloor k - 1\), we would have a uniform distribution, as we have seen before (because the range would be evenly divisible). Indeed, all we need to do is to discard the \(M \% k\) values at either the end or the beginning of the range, and then do modulo over the result; so this is practically a &ldquo;merge&rdquo; of the last two ideas. It would go something like this:</p><pre><code>unsigned int threshold = M - (M % k);
unsigned int randomNumber;
do {
    randomNumber = rand();
} while (randomNumber &gt;= threshold)
randomNumber = randomNumber % k;
</code></pre><p>We don&rsquo;t really need to do anything to prove that this is correct: it is clear that the first four lines sample a number from the range \(\{0, &mldr;, \lfloor \frac{M}{k} \rfloor k - 1\}\) uniformly at random (from the proof of the previous scheme), and then using modulo on that changes it to a uniform distribution with the desired range (due to the first scheme&rsquo;s proof).</p><p>The only interesting change here is the number of calls to <code>rand()</code>. Now, the probability that a number is in the desired range for the loop is \( \frac{M - (M \% k)}{M} = 1 - \frac{M \% k}{M}\), and thus the number of iterations is \(N \sim \text{Geometric}(1 - \frac{M \% k}{M})\). We can now look at the expected number of iterations for different values of \(k\) and \(M\):</p><div style=display:flex;margin:auto><div style="flex:0 0 50%;margin-top:50pt"><fieldset><label for=modulo-expectation-M>M</label>
<input id=modulo-expectation-M type=number min=0 value=2000 step=1 placeholder=M></fieldset></div><div id=modulo-expectation-plot style=flex:1></div></div><p>Indeed, this is pretty much what we would reasonably expect to happen: the bigger \(M \% k\) is the more wastage we incur, and thus more iterations are needed. We can prove, however, that the <em>expected</em> number of iterations is bounded by \(2\):</p><script type="math/tex;mode=display">\begin{split}
\mathbb{E}[N] &= \frac{1}{1 - \frac{M \% k}{M}}\\
    &= \frac{1}{1 - \frac{M - \lfloor \frac{M}{k} \rfloor k}{M}}\\
    &= \frac{M}{\lfloor \frac{M}{k} \rfloor k}\\
    &= 1 + \frac{M \% k}{\lfloor \frac{M}{k} \rfloor k}
\end{split}
</script><p>Where we have repeatedly used the fact that \(M = \lfloor \frac{M}{k} \rfloor k + (M \% k)\). Notice that \(\frac{M \% k}{\lfloor \frac{M}{k} \rfloor k}\) is strictly less than \(1\), because if it was \(1\) or more, we could increase the value of \(\lfloor \frac{M}{k} \rfloor\), which contradicts the definition of the division operator itself. Thus, the entire expression is less than 2. This means that our algorithm has a expected running time of \(\mathcal{O}(1)\), assuming the rand operation is \(\mathcal{O}(1)\).</p><p>Perhaps the last interesting question with regards to this algorithm is what the probability is that we will do more than \(t\) iterations before outputting a random number. Mingling with the CDF for the geometric distribution gets you:</p><script type="math/tex;mode=display">\begin{split}
P(N > t) &= (\frac{M \% k}{M})^t\\
    &= (1 - \lfloor \frac{M}{k} \rfloor \frac{k}{M})^t
\end{split}
</script><p>The closer \( \lfloor \frac{M}{k} \rfloor \frac{k}{M} \) is to \(1\), the less probable it will be to spend more iterations. Of course, this term looks pretty similar to the expected number of iterations, just inverted and divided by two:</p><div style=display:flex;margin:auto><div style="flex:0 0 50%;margin-top:50pt"><fieldset><label for=modulo-cdf-M>M</label>
<input id=modulo-cdf-M type=number min=0 value=2000 step=1 placeholder=M></fieldset></div><div id=modulo-cdf-plot style=flex:1></div></div><p>It is pretty easy to see that this term is always greater than \(\frac{1}{2}\). Plugging this into the previous formula, we get that \(P(N > t) \leq (\frac{1}{2})^t\).</p><p>{1} Knuth, Donald. 1994. Concrete Mathematics.</p></div><div class=content data-pagefind-ignore=all><br><div class=boxed><h3>Related Articles</h3><ol class=unlist><li><span class="subtitle is-6">(April 30, 2016)</span> <a href=/post/yet-another-proof-of-brookes-theorem/>Yet Another Proof of Brooke's Theorem</a></li></ol></div></div><button id=load-comments-button class="button is-primary is-active is-large is-fullwidth" style=display:none>Load Comments</button>
<script src=/js/comments.min.39e33edd67905b2b36477104baf1ec48ae8d66edab407617757a4adf0f6b75a0.js integrity="sha256-OeM+3WeQWys2R3EEuvHsSK6NZu2rQHYXdXpK3w9rdaA=" crossorigin=anonymous async defer></script></div></div></article></section><div class=top-button><a href=https://julian.bayardo.info/post/understanding-modulo-bias/#><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg></a></div><script src=/js/copycode.min.f9b11d6b28ddbf03b69f75a528e7d8768b374ae9336dcd284ebd1c764332fd6b.js integrity="sha256-+bEdayjdvwO2n3WlKOfYdos3Sukzbc0oTr0cdkMy/Ws=" crossorigin=anonymous async defer></script><script src=/js/toc-highlight.min.e7ab37b0afc209abb07ffa8102b73d478c9b74c36c80593bdccc9793fc60adb5.js integrity="sha256-56s3sK/CCauwf/qBArc9R4ybdMNsgFk73MyXk/xgrbU=" crossorigin=anonymous async defer></script><footer class=section style=padding-top:0><div class=container><hr><p style=float:left>&copy; Julian Bayardo Spadafora 2015-2024 | <a href=/privacy-policy/>Privacy Policy</a> | <a href=/terms-of-service/>Terms of Service</a></p><div style=float:right><a href=https://julian.bayardo.info/post/understanding-modulo-bias/#>Back to Top</a></div></div></footer><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[","]"]],processEscapes:!0,processEnvironments:!0,autoload:{color:[],colorV2:["color"]},packages:{"[+]":["noerrors"]}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"],ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process",renderActions:{find_script_mathtex:[10,function(e){for(const t of document.querySelectorAll('script[type^="math/tex"]')){const o=!!t.type.match(/; *mode=display/),n=new e.options.MathItem(t.textContent,e.inputJax[0],o),s=document.createTextNode("");t.parentNode.replaceChild(s,t),n.start={node:s,delim:"",n:0},n.end={node:s,delim:"",n:0},e.math.push(n)}},""]}},loader:{load:["input/asciimath","[tex]/noerrors"]}}</script><script type=text/javascript id=MathJax-script async defer src=/js/vendor/mathjax/tex-mml-chtml.js></script><script type=text/javascript async defer src=/post/understanding-modulo-bias/plots.js></script></body></html>