<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-us">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Processing Trees with Recursion Schemes | Julian through the Lens</title>

<meta property='og:title' content='Processing Trees with Recursion Schemes - Julian through the Lens'>
<meta property='og:description' content='A long time ago, I was in touch with a production system whose purpose was to run a piece of data through a decision tree. At every step, the output could be Good, Bad, Move Left, or Move Right; there were no leaves, since at the end you were supposed to always have returned either Good or Bad (this means it would be an error for you to get there).'>
<meta property='og:url' content='https://julian.bayardo.info/posts/processing-trees-recursion-schemes/'>
<meta property='og:site_name' content='Julian through the Lens'>
<meta property='og:type' content='article'><meta property='og:image' content='https://www.gravatar.com/avatar/fdbc036a46f3c0903c7e39459db599c0?s=256'><meta property='article:section' content='Posts'><meta property='article:tag' content='functional-programming'><meta property='article:tag' content='haskell'><meta property='article:published_time' content='2018-06-02T20:51:15-03:00'/><meta property='article:modified_time' content='2018-06-02T20:51:15-03:00'/><meta name='twitter:card' content='summary'><meta name='twitter:site' content='@'><meta name='twitter:creator' content='@'>
<link rel="stylesheet" href="/css/style.css"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://julian.bayardo.info/"><h1 class="title is-4">Julian through the Lens</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile"><a class="level-item" aria-label="email" href='mailto:julian@bayardo.info' target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="github" href='https://github.com/jbayardo' target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="linkedin" href='https://linkedin.com/in/jbayardo' target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path stroke-width="1.8" d="m5.839218,4.101561c0,1.211972 -0.974141,2.194011 -2.176459,2.194011s-2.176459,-0.982039 -2.176459,-2.194011c0,-1.211094 0.974141,-2.194011 2.176459,-2.194011s2.176459,0.982917 2.176459,2.194011zm0.017552,3.94922l-4.388022,0l0,14.04167l4.388022,0l0,-14.04167zm7.005038,0l-4.359939,0l0,14.04167l4.360816,0l0,-7.370999c0,-4.098413 5.291077,-4.433657 5.291077,0l0,7.370999l4.377491,0l0,-8.89101c0,-6.915523 -7.829986,-6.66365 -9.669445,-3.259423l0,-1.891237z"/>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      

      
    </nav>

  </div>
</section>

<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/functional-programming">#functional-programming</a>



  
  | <a class="subtitle is-6" href="/tags/haskell">#haskell</a>
  

      
    </div>
    <h2 class="subtitle is-6">June 2, 2018</h2>
    <h1 class="title">Processing Trees with Recursion Schemes</h1>
    
    <div class="content">
      <p>A long time ago, I was in touch with a production system whose purpose was to run a piece of data through a decision tree. At every step, the output could be Good, Bad, Move Left, or Move Right; there were no leaves, since at the end you were supposed to always have returned either Good or Bad (this means it would be an error for you to get there).</p>

<p>The nodes in the decision tree could be pretty much whatever: most of them were expert rules for determining certain cases and automatically marking them as good or bad, others were carefully crafted models. Some of these nodes also required access to internal APIs in order to fetch more data concerning what you were processing.</p>

<p>It operated on an environment that changed frequently, which meant that the patterns the tree was looking for had to be constantly adapted, and thus it was a requirement of the system to hotswap the nodes&rsquo; code.</p>

<p>The system was unable to do hotswapping, for whatever reasons that may be (I&rsquo;m no expert in Java, but it seems there are several ways to do so). This led someone to create their own scripting language.</p>

<p>The language itself was pretty bad, but what was good about it is that it was really nicely integrated: they had also built version control on top of the nodes&rsquo; code, and deployment was reasonably smooth if you were working with these sort of nodes.</p>

<p>The problem came when you wanted to do something with the nodes that was not supported within the scripting language, such as accessing APIs. In these cases, you had to go into each server that had the code in it, and replace the compiled Java classes with your new node&rsquo;s code, to then restart the server, causing it to detect your new code. Suffice it to say, this was a pain, and of course very much error prone.</p>

<p>A few days ago, I was running through <a href="https://twitter.com/importantshock">Patrick Thomson</a>&rsquo;s <a href="http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/">Introduction to Recursion Schemes</a> and this problem came to mind again. I thought it might be a good exercise in learning recursion schemes; and thus here we are. Before we start, you may want to go through at least the first one or two posts in Patrick&rsquo;s tutorials. Also, I&rsquo;ll be using Edward Kmett&rsquo;s <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> throughout, along with several language extensions and what not; you can see the finished code <a href="https://github.com/jbayardo/rule-engine">in my GitHub repository</a>.</p>

<p>To start with, we&rsquo;ll have our Tree:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#fff;font-weight:bold">import</span> <span style="color:#fff;font-weight:bold">qualified</span> Data.Functor.Foldable.TH <span style="color:#fff;font-weight:bold">as</span> R

<span style="color:#fff;font-weight:bold">data</span> <span style="color:#fff;font-weight:bold">Tree</span> a
  = <span style="color:#fff;font-weight:bold">Node</span> { value :: !a
         , left  :: <span style="color:#fff;font-weight:bold">Tree</span> a
         , right :: <span style="color:#fff;font-weight:bold">Tree</span> a }
  | <span style="color:#fff;font-weight:bold">Failure</span>
  <span style="color:#fff;font-weight:bold">deriving</span> (<span style="color:#fff;font-weight:bold">Functor</span>, <span style="color:#fff;font-weight:bold">Foldable</span>, <span style="color:#fff;font-weight:bold">Traversable</span>, <span style="color:#fff;font-weight:bold">Show</span>)

<span style="color:#fff;font-weight:bold">R</span>.makeBaseFunctor <span style="color:#fff;font-weight:bold">&#39;&#39;Tree</span></code></pre></div>
<p><strong>Observation:</strong> this type allows you to write trees that never end. We have no way to brace against this in the type system (that I know of), but you can definitely ask for the <code>left</code> and <code>right</code> to be strict, which would mean any such program would hang at the moment you try to make such a value, I think.</p>

<p>This <code>makeBaseFunctor</code> call ensures that we get the additional <code>TreeF</code> type with the &ldquo;continuation holes&rdquo; for the type. And then we&rsquo;ll have two crucial types:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#fff;font-weight:bold">data</span> <span style="color:#fff;font-weight:bold">Movement</span>
  = <span style="color:#fff;font-weight:bold">L</span>
  | <span style="color:#fff;font-weight:bold">R</span>
  <span style="color:#fff;font-weight:bold">deriving</span> (<span style="color:#fff;font-weight:bold">Show</span>, <span style="color:#fff;font-weight:bold">Eq</span>, <span style="color:#fff;font-weight:bold">Ord</span>, <span style="color:#fff;font-weight:bold">Enum</span>)

<span style="color:#fff;font-weight:bold">type</span> <span style="color:#fff;font-weight:bold">Outcome</span> d = <span style="color:#fff;font-weight:bold">Either</span> d <span style="color:#fff;font-weight:bold">Movement</span></code></pre></div>
<p>This is how we will encode the output of node: every node has to produce a value of type <code>Outcome d</code>, and we will just check whether it is a movement or an output value that was just produced. Thus, the type of what produces an outcome (which I&rsquo;m going to call <code>Rule</code> because it is the name that makes the most sense to me right now) is pretty clear:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#fff;font-weight:bold">type</span> <span style="color:#fff;font-weight:bold">Rule</span> m d = m (<span style="color:#fff;font-weight:bold">Outcome</span> d)</code></pre></div>
<p>Where we&rsquo;ll have a constraint in which we require <code>m</code> to be a <code>Monad</code> instance. This type, although pretty simple, will give us all the flexibility we need: <code>Tree (Rule m d)</code> has monadic actions at each node; when we run the monadic action, we&rsquo;ll get an <code>Outcome d</code>, which we can check for what to do next.</p>

<p>With these types, the function we need will have a signature that looks like this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">execute :: (<span style="color:#fff;font-weight:bold">Monad</span> m) =&gt; <span style="color:#fff;font-weight:bold">Tree</span> (<span style="color:#fff;font-weight:bold">Rule</span> m d) -&gt; m (<span style="color:#fff;font-weight:bold">Outcome</span> d)</code></pre></div>
<p>Almost. You could reach a <code>Failure</code> node, and thus there&rsquo;s no way you could possibly produce an <code>Outcome d</code>, which means you&rsquo;d be forced to error in some other way. Since using the <code>Monad</code> instance&rsquo;s <code>fail</code> function is considered evil, I just opted for this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">execute :: (<span style="color:#fff;font-weight:bold">MonadCatch</span> m) =&gt; <span style="color:#fff;font-weight:bold">Tree</span> (<span style="color:#fff;font-weight:bold">Rule</span> m d) -&gt; m (<span style="color:#fff;font-weight:bold">Outcome</span> d)</code></pre></div>
<p>There is yet another issue with this function signature: if the <code>Rule</code> throws an exception, then the entire process will interrupt; and we won&rsquo;t be able to distinguish between an error in the execution and an error in the rule (at least not <em>a priori</em>). Thus, I introduced yet another abstraction, which is that of an <code>Execution</code>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#fff;font-weight:bold">newtype</span> <span style="color:#fff;font-weight:bold">Execution</span> d = <span style="color:#fff;font-weight:bold">Execution</span>
  { _result :: <span style="color:#fff;font-weight:bold">Either</span> <span style="color:#fff;font-weight:bold">SomeException</span> (<span style="color:#fff;font-weight:bold">Outcome</span> d)
  } <span style="color:#fff;font-weight:bold">deriving</span> (<span style="color:#fff;font-weight:bold">Show</span>)

<span style="color:#fff;font-weight:bold">Lens</span>.makeLenses <span style="color:#fff;font-weight:bold">&#39;&#39;Execution</span>

failed :: <span style="color:#fff;font-weight:bold">Execution</span> d -&gt; <span style="color:#fff;font-weight:bold">Bool</span>
failed = isLeft . (^. result)

outcome :: <span style="color:#fff;font-weight:bold">Execution</span> d -&gt; <span style="color:#fff;font-weight:bold">Outcome</span> d
outcome = fromRight undefined . (^. result)

apply :: (<span style="color:#fff;font-weight:bold">MonadCatch</span> m) =&gt; <span style="color:#fff;font-weight:bold">Rule</span> m d -&gt; m (<span style="color:#fff;font-weight:bold">Execution</span> d)
apply rule =
  <span style="color:#fff;font-weight:bold">do</span> outcome &lt;- rule
     return <span style="color:#fff;font-weight:bold">Execution</span> {_result = <span style="color:#fff;font-weight:bold">Right</span> outcome}
     `catch` \exception -&gt; return <span style="color:#fff;font-weight:bold">Execution</span> {_result = <span style="color:#fff;font-weight:bold">Left</span> exception}

destruct ::
     (<span style="color:#fff;font-weight:bold">SomeException</span> -&gt; a) -&gt; (d -&gt; a) -&gt; (<span style="color:#fff;font-weight:bold">Movement</span> -&gt; a) -&gt; <span style="color:#fff;font-weight:bold">Execution</span> d -&gt; a
destruct e d m execution =
  <span style="color:#fff;font-weight:bold">case</span> execution ^. result <span style="color:#fff;font-weight:bold">of</span>
    <span style="color:#fff;font-weight:bold">Left</span> exception -&gt; e exception
    <span style="color:#fff;font-weight:bold">Right</span> outcome -&gt;
      <span style="color:#fff;font-weight:bold">case</span> outcome <span style="color:#fff;font-weight:bold">of</span>
        <span style="color:#fff;font-weight:bold">Left</span> decision -&gt; d decision
        <span style="color:#fff;font-weight:bold">Right</span> move -&gt; m move</code></pre></div>
<p>Indeed, an <code>Execution</code> is just the result from running a Rule. Furthermore, an <code>execute</code> with a signature as above won&rsquo;t be able to provide any debug information: we have no knowledge about the path that was taken in the tree. The easy way to solve this is to just output a <code>Tree</code>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">execute :: (<span style="color:#fff;font-weight:bold">MonadCatch</span> m)
  =&gt; <span style="color:#fff;font-weight:bold">Tree</span> (<span style="color:#fff;font-weight:bold">Rule</span> m d)
  -&gt; m (<span style="color:#fff;font-weight:bold">Tree</span> (<span style="color:#fff;font-weight:bold">Execution</span> d))</code></pre></div>
<p>The question now is which recursion scheme to use. At first I thought it would be a catamorphism, however, it simply isn&rsquo;t because the process we want to do is &ldquo;first run the rule, then make a decision on which way to go&rdquo;, which is different from &ldquo;run the two sides&rsquo; rules, then decide what to do with the current rule&rdquo;.</p>

<p>After a lot of time spent looking at the type signatures, it became clear that it is an anamorphism. The way I like to think about it is that, at every step, you have to unfold a new <code>Tree</code>; this requires you to provide the <code>value</code> for the <code>Node</code>, and its two sides. The <code>value</code> corresponds to the <code>Execution d</code>, and the two sides depend on the rule execution: if the rule said to finish, then both sides are <code>Failure</code>, if it said to go <code>L</code>, then just the <code>right</code> side is <code>Failure</code> while the <code>left</code> side holds the next <code>Rule m d</code> to execute (the other case is symmetric). Thus, we need a transformation of type:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">go :: (<span style="color:#fff;font-weight:bold">MonadCatch</span> m)
  =&gt; <span style="color:#fff;font-weight:bold">Tree</span> (<span style="color:#fff;font-weight:bold">Rule</span> m d)
  -&gt; m (<span style="color:#fff;font-weight:bold">TreeF</span> (<span style="color:#fff;font-weight:bold">Execution</span> d) (<span style="color:#fff;font-weight:bold">Tree</span> (<span style="color:#fff;font-weight:bold">Rule</span> m d)))</code></pre></div>
<p>Coding this is a fairly simple endeavor, as long as you have a monadic anamorphism. This is not as simple as it looks because you have to pick some sequencing for the effects of the <code>Monad</code>. There is an <a href="https://github.com/ekmett/recursion-schemes/issues/3">old closed bug</a> in the <code>recursion-schemes</code> GitHub repository with a discussion on the complexities. I just used the <code>anaM</code> definition from the first comment:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">anaM :: (<span style="color:#fff;font-weight:bold">Monad</span> m, <span style="color:#fff;font-weight:bold">Corecursive</span> b, <span style="color:#fff;font-weight:bold">Traversable</span> (<span style="color:#fff;font-weight:bold">Base</span> b))
  =&gt; (a -&gt; m (<span style="color:#fff;font-weight:bold">Base</span> b a))
  -&gt; a
  -&gt; m b
anaM coalg = recurse
  <span style="color:#fff;font-weight:bold">where</span>
    recurse = (return . embed) &lt;=&lt; mapM recurse &lt;=&lt; coalg</code></pre></div>
<p>With some additional foo, it turns out to be really easy to write this function down:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">deadendF ::a -&gt; b -&gt; <span style="color:#fff;font-weight:bold">TreeF</span> a b
deadendF a b = <span style="color:#fff;font-weight:bold">NodeF</span> a b b

conditionalF :: a -&gt; <span style="color:#fff;font-weight:bold">Tree</span> b -&gt; <span style="color:#fff;font-weight:bold">Movement</span> -&gt; <span style="color:#fff;font-weight:bold">TreeF</span> a (<span style="color:#fff;font-weight:bold">Tree</span> b)
conditionalF x branch <span style="color:#fff;font-weight:bold">L</span> = <span style="color:#fff;font-weight:bold">NodeF</span> {valueF = x, leftF = branch, rightF = <span style="color:#fff;font-weight:bold">Failure</span>}
conditionalF x branch <span style="color:#fff;font-weight:bold">R</span> = <span style="color:#fff;font-weight:bold">NodeF</span> {valueF = x, leftF = <span style="color:#fff;font-weight:bold">Failure</span>, rightF = branch}

branch :: <span style="color:#fff;font-weight:bold">Movement</span> -&gt; <span style="color:#fff;font-weight:bold">Tree</span> a -&gt; <span style="color:#fff;font-weight:bold">Tree</span> a
branch <span style="color:#fff;font-weight:bold">L</span> = left
branch <span style="color:#fff;font-weight:bold">R</span> = right

execute :: (<span style="color:#fff;font-weight:bold">MonadCatch</span> m)
  =&gt; <span style="color:#fff;font-weight:bold">Tree</span> (<span style="color:#fff;font-weight:bold">Rule</span> m d)
  -&gt; m (<span style="color:#fff;font-weight:bold">Tree</span> (<span style="color:#fff;font-weight:bold">Execution</span> d))
execute = anaM go
  <span style="color:#fff;font-weight:bold">where</span>
    go <span style="color:#fff;font-weight:bold">Failure</span> = return <span style="color:#fff;font-weight:bold">FailureF</span>
    go tree@<span style="color:#fff;font-weight:bold">Node</span> {value = rule} = <span style="color:#fff;font-weight:bold">do</span>
      !execution &lt;- apply rule
      <span style="color:#fff;font-weight:bold">let</span> endpoint = const $ deadendF execution <span style="color:#fff;font-weight:bold">Failure</span>
      return $ destruct endpoint endpoint
        (\move -&gt; conditionalF execution (branch move tree) move)
        execution</code></pre></div>
<p>This will be all for today. For the next post in the series, I&rsquo;ll cover how to summarize the execution trees in a meaningful way, so that we can have some statistics on the executions.</p>

      
    </div>
    
  </div>
</section>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

