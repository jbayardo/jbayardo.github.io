<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en" >

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    
    <title>Understanding Modulo Bias | Julian through the Lens</title>
    
    <meta property='og:title' content='Understanding Modulo Bias - Julian through the Lens'>
<meta property='og:description' content='It is often said that this code:
unsigned int randomNumber = rand() % k;  is a bad idea, at least if you are expecting a uniform distribution. I&rsquo;m going to try and explore this topic in a more formal fashion than I have seen so far.
The reason why it is bad is pretty elementary and easy to understand: imagine you have a random generator that outputs values between \(0\) and \(9\) (i.'>
<meta property='og:url' content='https://julian.bayardo.info/understanding-modulo-bias/'>
<meta property='og:site_name' content='Julian through the Lens'>
<meta property='og:type' content='article'><meta property='og:image' content='https://www.gravatar.com/avatar/fdbc036a46f3c0903c7e39459db599c0?s=256'><meta property='article:section' content=''><meta property='article:tag' content='math'><meta property='article:tag' content='probability'><meta property='article:published_time' content='2018-05-02T20:26:06-03:00'/><meta property='article:modified_time' content='2018-05-02T20:26:06-03:00'/><meta name='twitter:card' content='summary'><meta name='twitter:site' content='@BayardoJulian'><meta name='twitter:creator' content='@BayardoJulian'>

    
    <link href="https://julian.bayardo.info/index.xml" rel="alternate" type="application/rss+xml" title="Julian through the Lens" />
    
    <link rel="stylesheet" href="/css/style.css" /><link rel='stylesheet' href='https://julian.bayardo.info/css/own.css'><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="canonical" href="https://julian.bayardo.info/understanding-modulo-bias/">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    
    
    <script type="text/javascript" src="https://cdn.plot.ly/plotly-1.36.1.min.js"></script>
    
    

</head>

<body>
<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://julian.bayardo.info/">
          <h1 id="nav-heading" class="title is-4">Julian through the Lens</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="rss"
            href='/index.xml' target='_blank'
            rel='noopener'>
            <span class="icon">
              <i class>
<svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  <path d="M4 11a9 9 0 0 1 9 9"></path>
  <path d="M4 4a16 16 0 0 1 16 16"></path>
  <circle cx="5" cy="19" r="1"></circle>
</svg>
</i>
            </span>
          </a><a class="level-item" aria-label="github"
            href='https://github.com/jbayardo' target='_blank'
            rel='noopener'>
            <span class="icon">
              <i class>
<svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  <path
    d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" />
</svg>
</i>
            </span>
          </a><a class="level-item" aria-label="email"
            href='mailto:julian@bayardo.info' target='_blank'
            rel='noopener'>
            <span class="icon">
              <i class>
<svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" />
  <polyline points="22,6 12,13 2,6" />
</svg>
</i>
            </span>
          </a><a class="level-item" aria-label="linkedin"
            href='https://linkedin.com/in/jbayardo' target='_blank'
            rel='noopener'>
            <span class="icon">
              <i class>
<svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  <path stroke-width="1.8"
    d="m5.839218,4.101561c0,1.211972 -0.974141,2.194011 -2.176459,2.194011s-2.176459,-0.982039 -2.176459,-2.194011c0,-1.211094 0.974141,-2.194011 2.176459,-2.194011s2.176459,0.982917 2.176459,2.194011zm0.017552,3.94922l-4.388022,0l0,14.04167l4.388022,0l0,-14.04167zm7.005038,0l-4.359939,0l0,14.04167l4.360816,0l0,-7.370999c0,-4.098413 5.291077,-4.433657 5.291077,0l0,7.370999l4.377491,0l0,-8.89101c0,-6.915523 -7.829986,-6.66365 -9.669445,-3.259423l0,-1.891237z" />
</svg>
</i>
            </span>
          </a></nav>
      </div>
    </nav>

    

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <article class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/math">#math</a>



  
  | <a class="subtitle is-6" href="/tags/probability">#probability</a>
  

      
    </div>
    <h2 class="subtitle is-6">May 2, 2018</h2>
    <h1 class="title">Understanding Modulo Bias</h1>
    

    <div class="content">
      <p>It is often said that this code:</p>
<pre><code>unsigned int randomNumber = rand() % k;
</code></pre>
<p>is a bad idea, at least if you are expecting a uniform distribution. I&rsquo;m going to try and explore this topic in a more formal fashion than I have seen so far.</p>
<p>The reason why it is bad is pretty elementary and easy to understand: imagine you have a random generator that outputs values between \(0\) and \(9\) (i.e. <code>RAND_MAX</code> is \(10\)), and you wanted values between \(0\) and \(2\) (so you would set \(k = 3\) ). Then, we have the following mapping:</p>
<table>
    <tr>
        <th>rand()</th>
        <th>Random Number</th>
    </tr>
    <tr>
        <td>0, 3, 6, 9</td>
        <td>0</td>
    </tr>
    <tr>
        <td>1, 4, 7</td>
        <td>1</td>
    </tr>
    <tr>
        <td>2, 5, 8</td>
        <td>2</td>
    </tr>
</table>
<p>So, effectively, the \(P(\text{randomNumber} = 2) = \frac{3}{10}\); in contrast, \(P(\text{randomNumber} = 0) = \frac{4}{10}\). Essentially, the problem lies in the fact that since \(k\) does not evenly divide <code>RAND_MAX</code>, this gets you up to \(1\) more value falling into the first few numbers in the range. To get a feeling for this, you can play around with the plot below, which shows the precise probabilities for different values of <code>RAND_MAX</code> and \(k\):</p>
<div style="display:flex;margin:auto;">
  <div style="flex:0 0 50%;margin-top:50pt;">
    <form>
        <fieldset>
          <label for="modulo-bias-M"><code>RAND_MAX</code></label>
          <input id="modulo-bias-M" type="number" min="0" max="1000" value="11" step="1" placeholder="M">
        </fieldset>
        <fieldset>
            <label for="modulo-bias-k">k</label>
            <input id="modulo-bias-k" type="number" min="1" max="1000" value="10" step="1" placeholder="k">
        </fieldset>
    </form>
  </div>
  <div id="modulo-bias-plot" style="flex:1;"></div>
</div>
<p>Effectively, the effect of the parameter \(k\) becomes more pronounced when the value of \(M \% k\) gets bigger; until it gets too big (i.e. \(k = M - 1\)), and then it is almost as if you didn&rsquo;t have the problem. More formally, we can analyze this by setting \(X\) to be a discrete random variable such that \(R_X = \{0, &hellip;, M-1\}\), with \(M-1 \in \mathbb{N}\) being the highest achievable number for the random generator and \(P(X = i) = \frac{1}{M}\).</p>
<p>Let \(Y = X \% k\). What we want is to find out what the probability distribution function of \(Y\) is, since that will give us a way to properly understand what is happening. First of all, notice that \(R_Y = \{0, &hellip;, k-1\}\). Hence, the probability:</p>
<script type="math/tex; mode=display">
P(Y = i) = P(\cup_{j \in J_i} (X = j)) = \sum_{j \in J_i} P(X = j) = \frac{\#J_i}{M}
</script>
<p>Where \(J_i = \{x \in R_X : x \equiv i \text{(mod} k\text{)}\}\). Concretely, the probability that \(Y\) is in any particular equivalence class, is the number of elements in the class over the total number of elements we get to pick from. So the next thing to do is to calculate \(\#J_i\).</p>
<p>Elements belonging to \(J_i\) all have the same form: \(qk + i\), with \(q \in \mathbb{Z}\). However, they are bounded above by \(M-1\), and below by \(i\):</p>
<script type="math/tex; mode=display">
i \leq qk + i \leq M-1 \implies 0 \leq q \leq \lfloor\frac{M - 1 - i}{k}\rfloor
</script>
<p>Thus, \(\#J_i = \lfloor\frac{M - 1 - i}{k}\rfloor + 1\). Meaning that our probability distribution function is</p>
<script type="math/tex; mode=display">
P(Y = i) = \frac{\lfloor \frac{M - 1 - i}{k} \rfloor + 1}{M}
</script>
<p>We want to see that this sums to \(1\), since this would confirm that it is a probability distribution. I will use use the identities \(\lceil \frac{a}{b} \rceil = \lfloor \frac{a - 1}{b} \rfloor + 1\) and \(a = \sum_{i=0}^{b-1} \lceil \frac{a - i}{b} \rceil\), both proofs can be found in {1}:</p>
<script type="math/tex; mode=display">
\begin{split}
\sum_{i \in R_Y} P(Y = i) &= \sum_{i=0}^{k-1} (\frac{\lfloor\frac{M - 1 - i}{k}\rfloor + 1}{M}) \\
&= \frac{1}{M} \sum_{i=0}^{k-1} (\lfloor\frac{M - 1 - i}{k}\rfloor + 1) \\
&= \frac{1}{M} \sum_{i=0}^{k-1} \lceil\frac{M - i}{k}\rceil \\
&= \frac{1}{M} M = 1
\end{split}
</script>
<p>The fact that the distribution depends on the value of \(i\) is already a problem: we were seeking a uniform distribution, and hence expecting that \(P(Y=i) = \frac{1}{k}\). If you plot the function, you will see exactly the same plot as you were playing with above.</p>
<h1 id="how-bad-is-it">How bad is it?</h1>
<p>How bad this is depends on what you are doing. A more interesting question is how to quantify how bad it can be. One way to go about quantifying is to measure how different the distribution of \(Y\) is with respect to the distribution of \(Z\); <a href="https://en.wikipedia.org/wiki/Divergence_(statistics)">there are a myriad of ways to do this</a>, but I am going to use the <a href="https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence">Kullback-Leibler divergence</a>.</p>
<p>Thus, suppose \(Z\) was a uniformly distributed random variable such that \(R_Z = \{0, .., k - 1\}\) (i.e. the actual distribution we wanted to achieve). Given some \(M\), we know that \(k\) can range between \(1 \leq k \leq M - 1\); for each of these values, we have one probability distribution, call it \(Y\), and we can compute \(\text{KL}(Z||Y)\):</p>
<div style="display:flex;margin:auto;">
  <div style="flex:0 0 50%;margin-top:50pt;">
    <fieldset>
        <label for="modulo-distribution-M">M</label>
        <input id="modulo-distribution-M" type="number" min="0" value="2000" step="1" placeholder="M">
    </fieldset>
  </div>
  <div id="modulo-distribution-plot" style="flex:1;"></div>
</div>
<p>If you look at different values of \(M\), it will become clear that \(\text{KL}(Z||Y)\) only reaches 0 when \(k\) evenly divides \(M\); and thus some values of \(M\) don&rsquo;t ever get a point that reaches \(0\); specifically, these are the prime numbers.</p>
<p>Furthermore, the space between the zeros becomes bigger and bigger as \(M\) increases. This is basically because even divisors of \(M\) are more spaced out as they get larger; this is easy to see by looking at the prime decomposition of \(M = \prod_{i=1}^b p_i^{r_i} \): every even divisor can only look just like the decomposition, just with a lesser or equal value for each \(r_i\), which means that increases in value are multiplicative!.</p>
<p>The last key to understand this is the parabolas. Why do we have an inverted parabola between each even divisor?. That is simply because of how modulo works!:</p>
<ul>
<li>When increasing \(k\), one more value gets biased. This means that the generated distribution drifts away from the target distribution \(Z\).</li>
<li>When the number of biased values (\(M \% k\)) is roughly \(\frac{k}{2}\), we reach the highest point of the parabola.</li>
<li>After this we can only decrease: as more values become biased, the distribution becomes more and more like an uniform distribution again.</li>
</ul>
<h1 id="how-can-i-fix-this">How can I fix this?</h1>
<p>Perhaps the easiest fix is to do:</p>
<pre><code>unsigned int randomNumber = k;
while (randomNumber &gt;= k) randomNumber = rand(); 
</code></pre>
<p>This works just as intended: the produced number is always between \(0\) and \(k-1\), and it is distributed uniformly in the range. To see this, imagine we set \(T_i\) to be independent, identically distributed with a uniform distribution between \(0\) and \(M-1\); then we can compute the PDF of \(T\):</p>
<script type="math/tex; mode=display">
\begin{split}
P(T = i) &= \sum_{r=1}^{\infty} P(\wedge_{j=1}^{r - 1} T_j \geq k \wedge T_r = i) \\
    &= \sum_{r=1}^{\infty} P(T_r = i) \prod_{j=1}^{r-1} P(T_j \geq k) \\
    &= \sum_{r=1}^{\infty} \frac{1}{M} (1 - \frac{k}{M})^{r-1} \\
    &= \frac{1}{M} \sum_{r=0}^{\infty} (1 - \frac{k}{M})^{r} \\
    &= \frac{1}{M} \frac{1}{1 - (1 - \frac{k}{M})} \\
    &= \frac{1}{k}
\end{split}
</script>
<p>Which now looks exactly as we wanted it to!. Perhaps the next interesting question is how many times will we call <code>rand()</code> until we find a number that satisfies the constraint.</p>
<p>This can be easily answered: the probability that we receive a random number in the range is \(\frac{k}{M}\), and the random numbers generated are independent of each other; which means that the number of iterations \(N\) is a <a href="https://en.wikipedia.org/wiki/Geometric_distribution">geometric random variable</a>. Hence, we have that \(N \sim \text{Geometric}(\frac{k}{M})\), and thus we can expect to take \(\mathbb{E}[N] = \frac{M}{k}\) iterations until we generate a random number.</p>
<p>The expectation points out a problem in our code: if \(M \gg k\), which often happens in practical implementations where \(M\) is the maximum representable number, then the number of iterations is going to be high.</p>
<h1 id="what-now">What now?</h1>
<p>Well, the problem with the last idea is that we discard most of the numbers that we generate, while the problem with the former idea is that there are a set of numbers that bias our generator. The next idea is to try to discard just the numbers that bias the generator.</p>
<p>We can write \(M\) as \(\lfloor \frac{M}{k} \rfloor k + (M \% k)\); if we did the modulo technique on a generator with output between \(0\) and \(\lfloor \frac{M}{k} \rfloor k - 1\), we would have a uniform distribution, as we have seen before (because the range would be evenly divisible). Indeed, all we need to do is to discard the \(M \% k\) values at either the end or the beginning of the range, and then do modulo over the result; so this is practically a &ldquo;merge&rdquo; of the last two ideas. It would go something like this:</p>
<pre><code>unsigned int threshold = M - (M % k);
unsigned int randomNumber;
do {
    randomNumber = rand();
} while (randomNumber &gt;= threshold)
randomNumber = randomNumber % k;
</code></pre>
<p>We don&rsquo;t really need to do anything to prove that this is correct: it is clear that the first four lines sample a number from the range \(\{0, &hellip;, \lfloor \frac{M}{k} \rfloor k - 1\}\) uniformly at random (from the proof of the previous scheme), and then using modulo on that changes it to a uniform distribution with the desired range (due to the first scheme&rsquo;s proof).</p>
<p>The only interesting change here is the number of calls to <code>rand()</code>. Now, the probability that a number is in the desired range for the loop is \( \frac{M - (M \% k)}{M} = 1 - \frac{M \% k}{M}\), and thus the number of iterations is \(N \sim \text{Geometric}(1 - \frac{M \% k}{M})\). We can now look at the expected number of iterations for different values of \(k\) and \(M\):</p>
<div style="display:flex;margin:auto;">
  <div style="flex:0 0 50%;margin-top:50pt;">
    <fieldset>
      <label for="modulo-expectation-M">M</label>
      <input id="modulo-expectation-M" type="number" min="0" value="2000" step="1" placeholder="M">
    </fieldset>
  </div>
  <div id="modulo-expectation-plot" style="flex:1;"></div>
</div>
<p>Indeed, this is pretty much what we would reasonably expect to happen: the bigger \(M \% k\) is the more wastage we incur, and thus more iterations are needed. We can prove, however, that the <em>expected</em> number of iterations is bounded by \(2\):</p>
<script type="math/tex; mode=display">
\begin{split}
\mathbb{E}[N] &= \frac{1}{1 - \frac{M \% k}{M}}\\
    &= \frac{1}{1 - \frac{M - \lfloor \frac{M}{k} \rfloor k}{M}}\\
    &= \frac{M}{\lfloor \frac{M}{k} \rfloor k}\\
    &= 1 + \frac{M \% k}{\lfloor \frac{M}{k} \rfloor k}
\end{split}
</script>
<p>Where we have repeatedly used the fact that \(M = \lfloor \frac{M}{k} \rfloor k + (M \% k)\). Notice that \(\frac{M \% k}{\lfloor \frac{M}{k} \rfloor k}\) is strictly less than \(1\), because if it was \(1\) or more, we could increase the value of \(\lfloor \frac{M}{k} \rfloor\), which contradicts the definition of the division operator itself. Thus, the entire expression is less than 2. This means that our algorithm has a expected running time of \(\mathcal{O}(1)\), assuming the rand operation is \(\mathcal{O}(1)\).</p>
<p>Perhaps the last interesting question with regards to this algorithm is what the probability is that we will do more than \(t\) iterations before outputting a random number. Mingling with the CDF for the geometric distribution gets you:</p>
<script type="math/tex; mode=display">
\begin{split}
P(N > t) &= (\frac{M \% k}{M})^t\\
    &= (1 - \lfloor \frac{M}{k} \rfloor \frac{k}{M})^t
\end{split}
</script>
<p>The closer \( \lfloor \frac{M}{k} \rfloor \frac{k}{M} \) is to \(1\), the less probable it will be to spend more iterations. Of course, this term looks pretty similar to the expected number of iterations, just inverted and divided by two:</p>
<div style="display:flex;margin:auto;">
  <div style="flex:0 0 50%;margin-top:50pt;">
    <fieldset>
      <label for="modulo-cdf-M">M</label>
      <input id="modulo-cdf-M" type="number" min="0" value="2000" step="1" placeholder="M">
    </fieldset>
  </div>
  <div id="modulo-cdf-plot" style="flex:1;"></div>
</div>
<p>It is pretty easy to see that this term is always greater than \(\frac{1}{2}\). Plugging this into the previous formula, we get that \(P(N &gt; t) \leq (\frac{1}{2})^t\).</p>
<p>{1} Knuth, Donald. 1994. Concrete Mathematics.</p>

      
    </div>
    
  </article>
</section>

<section class="section" style="padding: 0px;">
    <div class="container has-text-centered">
        <hr />

        For comments and discussion, feel free to reach out via <a href="mailto:julian@bayardo.info">email</a>
        or <span class="twitter"></span><a href="https://twitter.com/search?q=https%3a%2f%2fjulian.bayardo.info%2funderstanding-modulo-bias%2f" rel="author">Twitter</a>
        </span>
    </div>
</section>
<section class="section" style="padding-top: 0px;">
  <div class="container">
    <hr />

    <p style="float: left;">&copy; Julian Bayardo Spadafora 2015-2020</p>

    <div style="float: right;">
      <a href="https://julian.bayardo.info/understanding-modulo-bias/#">Back to Top</a>
    </div>
  </div>
</section>

<script>
  
  (function addHeadingLinks() {
    var article = document.querySelector('div.content');
    var headings = article.querySelectorAll('h1, h2, h3, h4, h5, h6');
    headings.forEach(function (heading) {
      if (heading.id) {
        var link = document.createElement('a');
        link.innerHTML = '\n\u003csvg xmlns=\u0022http:\/\/www.w3.org\/2000\/svg\u0022 width=\u002216\u0022 height=\u002216\u0022 viewBox=\u00220 0 8 8\u0022\u003e\n  \u003cpath\n    d=\u0022M5.88.03c-.18.01-.36.03-.53.09-.27.1-.53.25-.75.47a.5.5 0 1 0 .69.69c.11-.11.24-.17.38-.22.35-.12.78-.07 1.06.22.39.39.39 1.04 0 1.44l-1.5 1.5c-.44.44-.8.48-1.06.47-.26-.01-.41-.13-.41-.13a.5.5 0 1 0-.5.88s.34.22.84.25c.5.03 1.2-.16 1.81-.78l1.5-1.5c.78-.78.78-2.04 0-2.81-.28-.28-.61-.45-.97-.53-.18-.04-.38-.04-.56-.03zm-2 2.31c-.5-.02-1.19.15-1.78.75l-1.5 1.5c-.78.78-.78 2.04 0 2.81.56.56 1.36.72 2.06.47.27-.1.53-.25.75-.47a.5.5 0 1 0-.69-.69c-.11.11-.24.17-.38.22-.35.12-.78.07-1.06-.22-.39-.39-.39-1.04 0-1.44l1.5-1.5c.4-.4.75-.45 1.03-.44.28.01.47.09.47.09a.5.5 0 1 0 .44-.88s-.34-.2-.84-.22z\u0022 \/\u003e\n\u003c\/svg\u003e\n';
        link.href = '#' + heading.id;
        link.style.float = 'right';
        link.style.borderBottom = '0';
        heading.append(link);
      }
    });
  })();
</script>

<script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\[', '\]']],
            processEscapes: true,
            processEnvironments: true,
            autoload: {
                color: [],
                colorV2: ['color']
            },
            packages: { '[+]': ['noerrors'] }
        },
        options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            ignoreHtmlClass: 'tex2jax_ignore',
            processHtmlClass: 'tex2jax_process',
            
            renderActions: {
                 
                find_script_mathtex: [10, function (doc) {
                    for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                        const display = !!node.type.match(/; *mode=display/);
                        const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                        const text = document.createTextNode('');
                        node.parentNode.replaceChild(text, node);
                        math.start = { node: text, delim: '', n: 0 };
                        math.end = { node: text, delim: '', n: 0 };
                        doc.math.push(math);
                    }
                }, '']
            }
        },
        loader: {
            load: ['input/asciimath', '[tex]/noerrors']
        }
    };
</script>

<script type="text/javascript" id="MathJax-script" async="true" defer="true"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>







<script type="text/javascript" async="true" defer="true" src="https://julian.bayardo.info/post/understanding-modulo-bias/plots.js"></script>



<script type="module" src="https://cdn.jsdelivr.net/npm/instant.page@5.1.0/instantpage.min.js"></script>

</body>

</html>